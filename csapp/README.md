## CSAPP的学习记录

<details>
<summary> 第一章 计算机系统漫游</summary>

#### 引言

计算机系统是由**硬件**和**系统软件**组成的,它们共同工作来运行应用程序.

#### 1.1 信息就是位+上下文

hello程序的生命周期是从一个**源程序**开始的,即程序员通过编辑器创建并保存的文本文件,文件名是hello.c.也是一个比特序列.

区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文.比如,在不同的上下文中,一个同样的字节序列可能表示一个整数,浮点数,字符串或者机器指令.

#### 1.2 程序被其他程序翻译成不同的格式

为了在系统上运行hello.c程序,每条C语句都必须被其他程序转化为一系列的低级机器语言指令.然后这些指令按照一种称为可执行目标程序的格式打好包,并以二进制磁盘文件的形式存放起来.目标程序也成为可执行目标文件.

在Unix系统上,从源文件到目标文件的转化是由编译器驱动程序完成的:

linux> gcc -o hello hello.c

![1](https://i.loli.net/2020/07/11/tavni1F3OQq9wZR.png)

#### 1.7 进程

一个CPU看上去都像是并发地执行多个进程,这是通过处理器在进程间切换来实现的.操作系统实现这种交错执行的进程称为**上下文切换.**]

操作系统保持跟踪进程运行所需的所有状态信息.这种状态,也就是**上下文**,包括很多信息,比如PC和寄存器文件的当前值,以及主存的内容.

#### 1.7.2 进程

一个进程实际上可以由多个称为线程的执行单元组成,每个线程都运行在进程的上下文中,并共享同样的代码和全局数据.

#### 1.7.3 虚拟内存

虚拟内存是一个抽象概念,它为每个进程提供了一个假象,即每个进程都在独占地使用主存.每个进程看见的内存都是一致的,称为虚拟地址空间.

虚拟地址空间由大量精确定义的区构成.

从最低的地址开始:

- 程序代码和数据
- 堆
- 共享库
- 栈
- 内核虚拟空间

#### 1.9.1 Amdahl定律

> S=1/(1-a+a/n)

主要观点:  要想显著加速整个系统,必须提升全系统中相当大的部分的速度.

#### 1.9.2 并发与并行

- 并发是指一个同时具有多个活动的系统,其目的是让计算机做的更多
- 并行则是指用并发来使一个系统运行得更快,目的是让计算机运行的更快.

主要是三个层次

- 线程级并发
- 指令级并行
- 单指令、多数据并行

#### 1.9.3 抽象

操作系统内核就是应用程序和硬件之间的媒介.它提供了三个基本的抽象:

1. 文件是对I/O设备的抽象
2. 虚拟内存是对主存和磁盘的抽象
3. 进程是处理器、主存和I/O设备的抽象.
</details>
<details>
<summary> 第二章 信息的表示和处理</summary>
> 孤立的一个位不是非常有用.但是,当把位组合在一起,再加上某种解释,即赋予不同的可能位模式以含义,就能够表示任何有限集合的元素.

#### intro

计算机的表示法是用有限数量的位来对一个数字编码,因此,但结果太大以至于不能表示时,某些计算就会溢出.

整数的表示虽然只能编码一个相对较小的数值范围,但是这种表示是准确的;

而浮点数虽然可以编码一个较大的数值范围,但是这种表示只是近似的.

#### 2.1.2 字数据大小

每台计算机都有一个字长,指明**指针数据**的标称大小.因为虚拟地址是以这样的一个字来编码的,所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小.

使用确定大小的整数类型是程序员精确控制数据表示的最佳途径.其中包括ISO C99引入的int32_t和int64_t,分别为4字节和8字节.这样会有更好的移植性. 使用sizeof也是一种好方法.

#### 2.1.3 寻址和字节顺序

关于大小端的问题:

比如int x=0x1234567.

如果是大端法就是 01 23 45 67

小端法则是 67 45 23 01

大多数Intel兼容机都只有小端模式.

讲解程序代码: [show_byte.cpp](https://github.com/whhhite/skr_university_learning_record/blob/master/csapp/%E7%AC%AC%E4%BA%8C%E7%AB%A0/show_bytes.cpp)

##### 练习2.6:

len是不包括最后的\x00的.

##### 练习2.11:

inplace_swap这个函数是异或置换,所以中间值置0

#### 2.1.7 C语言中的位级运算

位级运算的一个常见应用是实现掩码运算，掩码是一个位模式。使用类似~0得到全1的掩码,这样的代码具有移植性.

##### 练习2.25:

length=0

0U-1=UMax,所以访问了非法地址. coredump

##### 练习2.26:

无符号数,小减大,会产生一个很大的无符号数.

#### 函数getpeername的安全漏洞

问题是由于数据类型的不匹配造成的:在一个地方是无符号数,另一个地方是有符号数.

##### 练习2.27

return (x+y)>=x 

##### 练习2.30

正溢出: x>=0 && y>=0 && (x+y)<0

负溢出: x<0 && y<0 && (x+y)>0

##### 练习2.32

x>0 y=INT_MIN,两者异号不判断溢出,但其实是溢出了.

[tsub_ok.cpp](https://github.com/whhhite/skr_university_learning_record/blob/master/csapp/%E7%AC%AC%E4%BA%8C%E7%AB%A0/show_bytes.cpp)

#### XDR库中的安全漏洞

问题是由于乘法溢出,导致复制的字节大于已分配的缓冲区的界限.

##### 练习2.37

由于uint64_t的强制类型转换,在asize这部分还不会溢出.

但是由于malloc的参数类型和是size_t,在这里还是会产生溢出.

应该修改成:

```
  uint64_t asize = ele_cnt * (uint64_t) ele_size;
  unsigned int asize2 = ele_cnt * ele_size;
  if (asize == asize2) {//执行分配 }
  else { //抛出异常}
```

#### 2.3.6 乘以常数

由于整数乘法比移位和加法的代价要大得多,许多C语言编译器试图以移位,加法和减法的组合消除很多整数乘以常数的情况.

如: x*14 则根据 14=2^3+2^2+2,编译器会重写成(x<<3)+(x<<2)+(x<<1)

##### 练习题2.42

见[div_16.cpp](https://github.com/whhhite/skr_university_learning_record/blob/master/csapp/%E7%AC%AC%E4%BA%8C%E7%AB%A0/div16.cpp)

##### 练习题2.46

A.对齐后得到结果是 0.00000000000000000000000[1100]

B.2^(-24)

C.运行了100个小时,有100 * 3600 * 10次,所以误差还是挺大的,大概0.343秒

D.差了686米

#### 2.4.2 IEEE浮点表示

V=(-1)^s × M × 2^E

将浮点数的位表示划分为三个字段

- 一个单独的符号位直接编码符号s
- k位的阶码字段 exp
- n位的小数字段frac

float中 s=1 k=8 n=23 

double中 s=1 k=11 n=52

分为三种情况:

1. 规格化的值

偏置值Bias=2^(k-1)-1

阶码的值 E=e-Bias

M=1+f,也叫做隐含的以1开头的表示

2. 非规划化的值

E=1-Bias

M=f

3. 特殊值

当阶码全为1,小数全为0则为无穷

小数非0时,则表示为NaN(Not a number)

#### 2.4.5 浮点运算

浮点加法有个最大的问题，就是不具有结合性，大数会把小的数字吃掉，这是因为舍入的原因。乘法也一样

##### 练习2.54

int转float 有可能被舍入,
</details>
<details>
<summary> 第三章 程序的机器级表示</summary>
#### 3.2.1 机器级代码

- 程序计数器(通常称为"PC",在x86-64中用%rip表示)给出将要执行的下一条指令在内存中的地址.
- 整数寄存器文件中包括16个命名的位置,分别存储64位的值.这些寄存器可以存储地址或整数数据
- 一组向量寄存器可以存放一个或多个整数或浮点数值

程序内存包含:程序的可执行机器代码,操作系统需要的一些信息,用来管理过程调用和返回的运行时栈,以及用户分配的内存块(比如说用malloc库函数分配的)



#### 3.4.1 操作数指示符

大多数指令有一个或多个操作数,指示出执行一个操作中要使用的源数据值,以及放置结果的目的位置.

各种不同的操作数的可能性被分为三种类型:

1. 立即值, 用来表示常数, 用$开头.可以直接写整数,汇编器会将其编译成对应的二进制格式.
2. 寄存器, 即寄存器的名称, 代表某个寄存器内部的值.
3. 内存引用, 代表某个内存地址的值, 也就是寻址或者说是取地址运算, 用括号包起来一个值, 这个值可以是常量, 取得的值或者是计算所得.

寻址的模式,最常用的形式是 

`计算出的内存地址 = 立即数偏移量 + Rb + Ri * s`



##### 练习题3.1

|      地址      |  值  |
| :------------: | :--: |
| 内存地址 0x100 | 0xFF |
| 内存地址 0x104 | 0xAB |
| 内存地址 0x108 | 0x13 |
| 内存地址 0x10C | 0x11 |

| 寄存器 |  值   |
| :----: | :---: |
|  %rax  | 0x100 |
|  %rcx  |  0x1  |
|  %rdx  |  0x3  |



|     操作数      |                              值                              |
| :-------------: | :----------------------------------------------------------: |
|      %rax       |                            0x100                             |
|      0x104      |                  表示寻绝对地址,结果是0xAB                   |
|     $0x108      |                          常量 0x108                          |
|     (%rax)      |        将%rax寄存器中的0x100当做地址寻址,结果是 0xFF         |
|     4(%rax)     | 表示基址+偏移量地址,为 %rax中的 0x100地址加0x4,即 0x104地址,结果为0xAB |
|  9(%rax, %rdx)  |    表示变址寻址, 为 9+ 0x100 + 0x3 = 0x10C, 所以值是0x11     |
| 260(%rcx, %rdx) |           同理地址是 260 + 1 + 3 = 0x108, 值是0x13           |
|  0xFC(,%rcx,4)  |       比例变址寻址,结果是 0xFC + 4 = 0x100, 值是 0xFF        |
| (%rax, %rdx, 4) |  带s的变址寻址,计算后的内存是 0x100 + 4*3 = 0x10C,值是0x11   |

#### 3.4.2 数据传送指令

##### MOV类

> 指令为: MOV  S , D
>
> 效果为: 传送 D<-S

在这里把S叫做源操作数, 把D叫做目的操作数.

MOV类由四条指令构成:**movb**,**movw**,**movl**,**movq**,区别是操作数大小不同.

x86-64限制了MOV的两个操作数都不能都是内存地址,如果要实现,就找寄存器当工具人. 

大多数情况中,MOV指令只会更新目的操作数指定的那些寄存器字节或内存位置.唯一例外是,**movl**指令以寄存器作为目的时,会把该寄存器的高位4字节设置为0.这是由于x86-64采用的惯例,即任何为寄存器生成的32位值得指令都会把该寄存器的高位部分置为0.

常规的movq命令只能处理32位的源操作数,将其符号扩展得到64位. 而movbsq可以直接将64位数作为源操作数, 但目的只能是寄存器.

关于MOVZ和MOVS,这两个指令都是在将较小的源值复制到较大的目的时使用.

区别在于MOVZ使用0来填充,而MOVS使用符号位来填充.

在MOVS中有个指令cltq,用于将%eax符号扩展到%rax,等价于movslq %eax,%rax.



##### 练习题3.3

`movb $0xF, (%ebx)`	内存引用的寄存器必须是4bytes，改成`movb $0xF, (%rbx)`
`movb %al, %sl`	没有叫做`sl`的寄存器,只有`sil`和`spl`.
`movl %eax, %rdx`	寄存器大小不匹配



##### 练习题3.4

|     src_t     |  dest_t  |                             指令                             |
| :-----------: | :------: | :----------------------------------------------------------: |
|     long      |   long   |          movq (%rdi),%rax; <br />move %rax, (%rsi)           |
|     char      |   int    | 扩展符号到32位,<br />movsbl (%rdi), %eax;<br />movl %eax, (%rsi) |
|     char      | unsigned |         movsbl (%rdi), %eax;<br />movl %eax, (%rsi)          |
| unsigned char |   long   | unsigned, 零扩展. 零扩展没有扩展到64位的指令,32位就相当于64位的零扩展了.<br />movzbl (%rdi), %rax<br />movq %rax, (%rsi) |
|      int      |   char   |  区别在第二步<br />movl (%rdi), %eax<br />movb %al, (%rsi)   |



##### 练习题3.5

不考虑编译优化的话是:

```
void decode1(long *xp, long *yp, long *zp){
	long temp1 = *xp;
	long temp2 = *yp;
	long temp3 = *zp;
	*yp = temp1;
	*zp = temp2;
	*xp = temp3;
}
```



#### 3.4.4 压入和弹出栈数据

从%rbp寄存器中压一个四字入栈的指令`pushq`可以分解为:

```popq可以分解为:
subq $8, %rsp
push %rbp, (%rsp)
```

`popq`可以分解为:

```
movq (%rsp), %rax
addq %$8, %rsp
```



#### 3.5.3 移位操作

移位量可以是一个立即数,或者放在单字节寄存器%cl上.

##### 练习3.9

```
// x in %rdi, n in %rsi
shift_left4_rightn:
    movq %rdi, %rax;
    salq  $4, %rax     # x <<= 4
    movq %esi, %ecx;
    sarq  %cl, %rax    # x >>= n
```

##### 练习3.10

```
long t1 = x | y;
long t2 = t1 >> 3;
long t3 = ~t2;
long t4 = z - t3;
```

##### 练习3.11:

用于置0.比move开销小.



#### 3.5.5 特殊的算术操作

`imulq`和`mulqs`: "单操作数"乘法指令,用于处理128位的乘积.其中一个参数必须在%rax中.结果用%rdx存高64位,用%rax存低64位.

`idivq`:这个是有符号数的除法指令, 操作数S是除数, 被除数固定使用%rax作为低64字节, %rdx作为高64字节. 除法进行完之后,商存储在%rax中, 而余数存储在%rdx中.

`cqto`: 这个指令没有操作数, 将%rdx的位设置为%rax的符号位



##### 练习3.12

把`cqto`改成把%rdx的位置为0;



#### 3.6.1条件码

1. CF 进位标志, 最近的操作使最高位产生进位
2. ZF 零标志, 最近的操作的结果得到0
3. SF 符号标志, 最近的操作结果是负数
4. OF 溢出标志, 最近的操作导致补码溢出,正负溢出都算



`CMP`和`TEST`只改变条件码,前者是减法,后者是与(检测正负0).

同时注意`CMP`的操作数与`SUB`是相反的.

`SET`和`JMP`都可以根据条件码进行判断操作.

##### 练习3.13

- ```
  cmpl  %esi, %edi
  setl  %al
  ```

  后缀 ‘l’ 和寄存器指示符表明是 32 位操作数，而且调用的是有符号的小于比较。所以 `data_t` 一定是 int 。

- ```
  cmpw  %si, %di
  setge %al
  ```

  后缀 ‘w’ 和寄存器指示符表明是 16 位操作数，而且调用的是有符号的大于等于。所以 `data_t` 一定是 short。

- ```
  cmpb  %sil, %dil
  setbe %al
  ```

  后缀 ‘b’ 和寄存器指示符表明是 8 位操作数，而且调用的是无符号小于等于。所以 `data_t` 一定是 unsigned char 。

- ```
  cmpq  %rsi, %rdi
  setne %al
  ```

  后缀 ‘q’ 和寄存器指示符表明是 64 位操作数，同时比较符号是 `!=` ，有符号、无符号和指针参数都是一样的。所以 `data_t` 可以是 long、unsigned long 或 char * 。



`JMP`三种用法:

1. `JMP .L1`  等于goto
2. `JMP *%rax ` 用%rax的值作为跳转目标
3. `JMP *(%rax) `以%rax的值来读地址,从内存中读出并且跳转.



##### 练习3.15

```
4003fa: 74 02    je    XXXXXX
4003fc: ff do    callq *%rax
```

> je 指令的目标为 `0x4003fc + 0x02 = 0x4003fe` 

```
40042f: 74 f4    je   XXXXXX
400431: 5d       pop  %rbp
```

> je 指令的目标为 `0x400431 - 12（0xf4是-12的一个字节的补码表示）= 0x400425` 

```
XXXXXX: 77 02    ja   400547
XXXXXX: 5d       pop  %rbp
```

> 跳转目标是绝对地址 `0x400547` 。根据字节编码，一定在距离 pop 指令 `0x2` 的地址处。所以，pop 指令地址为 `0x400547 - 0x2 = 0x400545` 。**注意，ja 指令的编码需要 2 个字节。**所以 ja 指令的地址为 `0x400543`处。

```
4005e8: e9 73 ff ff ff     jmp  XXXXXX
4005ed: 90                 nop
```

> 偏移量是 `0xffffff73` ，也就是 `-141` 。所以跳转目标为 `0x4005ed - 141 = 0x400560` 



##### 练习3.21

```
long test(long x, long y) {
    long val = 8 * x;
    if (y > 0) {
        if (x < y)
            val = y - x;
        else
            val = x & y;
    } else if (y <= -2)
        val = x + y;
    return val;
}
```

##### 练习3.23

A.`%rax` 存放 x ，`%rcx` 存放 y ，`%rdx` 存放 n 

B. 用`leaq`指令 实现+y和++;

##### 练习3.24

```
long loop_while(long a, long b)
{
    long result = 1;
    while (a < b) {
        result = result * (a + b);
        a = a + 1 ;
    }
    return result;
}
```

#### 3.7过程

过程是软件中一种很重要的抽象.它提供了一种封装代码的方式,用一组指定的参数和一个可选的返回值实现了某种功能.过程在不同的语言中的表现形式不同, 比如函数, 方法等.

##### 3.7.3 数据传送

其实就是调用规则.

| 操作数大小 | 参数数量 |      |      |      |      |      |
| :--------: | :------: | :--: | :--: | :--: | :--: | ---- |
|            |    1     |  2   |  3   |  4   |  5   | 6    |
|     64     |   %rdi   | %rsi | %rdx | %rcx | %r8  | %r9  |
|     32     |   %edi   | %esi | %edx | %ecx | %r8d | %r9d |
|     16     |   %di    | %si  | %dx  | %cx  | %r8w | %r9w |
|     8      |   %dil   | %sil | %dl  | %cl  | %r8b | %r9b |

多于6个参数的放栈上.

##### 练习3.33

根据 size得知 sizeof(a)+sizeof(b)=6

所以一个为4,一个为2.且4扩8,2变1.

`int procprob(int a, short b, long *u, char *v)`
`int procprob(int b, short a, long *v, char *u)`

</details>
## CSAPP的学习记录

<details>
<summary> 第一章 计算机系统漫游</summary>

#### 引言

计算机系统是由**硬件**和**系统软件**组成的,它们共同工作来运行应用程序.

#### 1.1 信息就是位+上下文

hello程序的生命周期是从一个**源程序**开始的,即程序员通过编辑器创建并保存的文本文件,文件名是hello.c.也是一个比特序列.

区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文.比如,在不同的上下文中,一个同样的字节序列可能表示一个整数,浮点数,字符串或者机器指令.

#### 1.2 程序被其他程序翻译成不同的格式

为了在系统上运行hello.c程序,每条C语句都必须被其他程序转化为一系列的低级机器语言指令.然后这些指令按照一种称为可执行目标程序的格式打好包,并以二进制磁盘文件的形式存放起来.目标程序也成为可执行目标文件.

在Unix系统上,从源文件到目标文件的转化是由编译器驱动程序完成的:

linux> gcc -o hello hello.c

![1](https://i.loli.net/2020/07/11/tavni1F3OQq9wZR.png)

#### 1.7 进程

一个CPU看上去都像是并发地执行多个进程,这是通过处理器在进程间切换来实现的.操作系统实现这种交错执行的进程称为**上下文切换.**]

操作系统保持跟踪进程运行所需的所有状态信息.这种状态,也就是**上下文**,包括很多信息,比如PC和寄存器文件的当前值,以及主存的内容.

#### 1.7.2 进程

一个进程实际上可以由多个称为线程的执行单元组成,每个线程都运行在进程的上下文中,并共享同样的代码和全局数据.

#### 1.7.3 虚拟内存

虚拟内存是一个抽象概念,它为每个进程提供了一个假象,即每个进程都在独占地使用主存.每个进程看见的内存都是一致的,称为虚拟地址空间.

虚拟地址空间由大量精确定义的区构成.

从最低的地址开始:

- 程序代码和数据
- 堆
- 共享库
- 栈
- 内核虚拟空间

#### 1.9.1 Amdahl定律

> S=1/(1-a+a/n)

主要观点:  要想显著加速整个系统,必须提升全系统中相当大的部分的速度.

#### 1.9.2 并发与并行

- 并发是指一个同时具有多个活动的系统,其目的是让计算机做的更多
- 并行则是指用并发来使一个系统运行得更快,目的是让计算机运行的更快.

主要是三个层次

- 线程级并发
- 指令级并行
- 单指令、多数据并行

#### 1.9.3 抽象

操作系统内核就是应用程序和硬件之间的媒介.它提供了三个基本的抽象:

1. 文件是对I/O设备的抽象
2. 虚拟内存是对主存和磁盘的抽象
3. 进程是处理器、主存和I/O设备的抽象.
</details>
<details>
<summary> 第二章 信息的表示和处理</summary>
> 孤立的一个位不是非常有用.但是,当把位组合在一起,再加上某种解释,即赋予不同的可能位模式以含义,就能够表示任何有限集合的元素.

#### intro

计算机的表示法是用有限数量的位来对一个数字编码,因此,但结果太大以至于不能表示时,某些计算就会溢出.

整数的表示虽然只能编码一个相对较小的数值范围,但是这种表示是准确的;

而浮点数虽然可以编码一个较大的数值范围,但是这种表示只是近似的.

#### 2.1.2 字数据大小

每台计算机都有一个字长,指明**指针数据**的标称大小.因为虚拟地址是以这样的一个字来编码的,所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小.

使用确定大小的整数类型是程序员精确控制数据表示的最佳途径.其中包括ISO C99引入的int32_t和int64_t,分别为4字节和8字节.这样会有更好的移植性. 使用sizeof也是一种好方法.

#### 2.1.3 寻址和字节顺序

关于大小端的问题:

比如int x=0x1234567.

如果是大端法就是 01 23 45 67

小端法则是 67 45 23 01

大多数Intel兼容机都只有小端模式.

讲解程序代码: [show_byte.cpp](https://github.com/whhhite/skr_university_learning_record/blob/master/csapp/%E7%AC%AC%E4%BA%8C%E7%AB%A0/show_bytes.cpp)

##### 练习2.6:

len是不包括最后的\x00的.

##### 练习2.11:

inplace_swap这个函数是异或置换,所以中间值置0

#### 2.1.7 C语言中的位级运算

位级运算的一个常见应用是实现掩码运算，掩码是一个位模式。使用类似~0得到全1的掩码,这样的代码具有移植性.

##### 练习2.25:

length=0

0U-1=UMax,所以访问了非法地址. coredump

##### 练习2.26:

无符号数,小减大,会产生一个很大的无符号数.

#### 函数getpeername的安全漏洞

问题是由于数据类型的不匹配造成的:在一个地方是无符号数,另一个地方是有符号数.

##### 练习2.27

return (x+y)>=x 

##### 练习2.30

正溢出: x>=0 && y>=0 && (x+y)<0

负溢出: x<0 && y<0 && (x+y)>0

##### 练习2.32

x>0 y=INT_MIN,两者异号不判断溢出,但其实是溢出了.

[tsub_ok.cpp](https://github.com/whhhite/skr_university_learning_record/blob/master/csapp/%E7%AC%AC%E4%BA%8C%E7%AB%A0/show_bytes.cpp)

#### XDR库中的安全漏洞

问题是由于乘法溢出,导致复制的字节大于已分配的缓冲区的界限.

##### 练习2.37

由于uint64_t的强制类型转换,在asize这部分还不会溢出.

但是由于malloc的参数类型和是size_t,在这里还是会产生溢出.

应该修改成:

```
  uint64_t asize = ele_cnt * (uint64_t) ele_size;
  unsigned int asize2 = ele_cnt * ele_size;
  if (asize == asize2) {//执行分配 }
  else { //抛出异常}
```

#### 2.3.6 乘以常数

由于整数乘法比移位和加法的代价要大得多,许多C语言编译器试图以移位,加法和减法的组合消除很多整数乘以常数的情况.

如: x*14 则根据 14=2^3+2^2+2,编译器会重写成(x<<3)+(x<<2)+(x<<1)

##### 练习题2.42

见[div_16.cpp](https://github.com/whhhite/skr_university_learning_record/blob/master/csapp/%E7%AC%AC%E4%BA%8C%E7%AB%A0/div16.cpp)

##### 练习题2.46

A.对齐后得到结果是 0.00000000000000000000000[1100]

B.2^(-24)

C.运行了100个小时,有100 * 3600 * 10次,所以误差还是挺大的,大概0.343秒

D.差了686米

#### 2.4.2 IEEE浮点表示

V=(-1)^s × M × 2^E

将浮点数的位表示划分为三个字段

- 一个单独的符号位直接编码符号s
- k位的阶码字段 exp
- n位的小数字段frac

float中 s=1 k=8 n=23 

double中 s=1 k=11 n=52

分为三种情况:

1. 规格化的值

偏置值Bias=2^(k-1)-1

阶码的值 E=e-Bias

M=1+f,也叫做隐含的以1开头的表示

2. 非规划化的值

E=1-Bias

M=f

3. 特殊值

当阶码全为1,小数全为0则为无穷

小数非0时,则表示为NaN(Not a number)

#### 2.4.5 浮点运算

浮点加法有个最大的问题，就是不具有结合性，大数会把小的数字吃掉，这是因为舍入的原因。乘法也一样

##### 练习2.54

int转float 有可能被舍入,
</details>

<details>
<summary> 第三章 程序的机器级表示</summary>

#### 3.2.1 机器级代码


- 程序计数器(通常称为"PC",在x86-64中用%rip表示)给出将要执行的下一条指令在内存中的地址.
- 整数寄存器文件中包括16个命名的位置,分别存储64位的值.这些寄存器可以存储地址或整数数据
- 一组向量寄存器可以存放一个或多个整数或浮点数值

程序内存包含:程序的可执行机器代码,操作系统需要的一些信息,用来管理过程调用和返回的运行时栈,以及用户分配的内存块(比如说用malloc库函数分配的)



#### 3.4.1 操作数指示符

大多数指令有一个或多个操作数,指示出执行一个操作中要使用的源数据值,以及放置结果的目的位置.

各种不同的操作数的可能性被分为三种类型:

1. 立即值, 用来表示常数, 用$开头.可以直接写整数,汇编器会将其编译成对应的二进制格式.
2. 寄存器, 即寄存器的名称, 代表某个寄存器内部的值.
3. 内存引用, 代表某个内存地址的值, 也就是寻址或者说是取地址运算, 用括号包起来一个值, 这个值可以是常量, 取得的值或者是计算所得.

寻址的模式,最常用的形式是 

`计算出的内存地址 = 立即数偏移量 + Rb + Ri * s`



##### 练习题3.1

|      地址      |  值  |
| :------------: | :--: |
| 内存地址 0x100 | 0xFF |
| 内存地址 0x104 | 0xAB |
| 内存地址 0x108 | 0x13 |
| 内存地址 0x10C | 0x11 |

| 寄存器 |  值   |
| :----: | :---: |
|  %rax  | 0x100 |
|  %rcx  |  0x1  |
|  %rdx  |  0x3  |



|     操作数      |                              值                              |
| :-------------: | :----------------------------------------------------------: |
|      %rax       |                            0x100                             |
|      0x104      |                  表示寻绝对地址,结果是0xAB                   |
|     $0x108      |                          常量 0x108                          |
|     (%rax)      |        将%rax寄存器中的0x100当做地址寻址,结果是 0xFF         |
|     4(%rax)     | 表示基址+偏移量地址,为 %rax中的 0x100地址加0x4,即 0x104地址,结果为0xAB |
|  9(%rax, %rdx)  |    表示变址寻址, 为 9+ 0x100 + 0x3 = 0x10C, 所以值是0x11     |
| 260(%rcx, %rdx) |           同理地址是 260 + 1 + 3 = 0x108, 值是0x13           |
|  0xFC(,%rcx,4)  |       比例变址寻址,结果是 0xFC + 4 = 0x100, 值是 0xFF        |
| (%rax, %rdx, 4) |  带s的变址寻址,计算后的内存是 0x100 + 4*3 = 0x10C,值是0x11   |

#### 3.4.2 数据传送指令

##### MOV类

> 指令为: MOV  S , D
>
> 效果为: 传送 D<-S

在这里把S叫做源操作数, 把D叫做目的操作数.

MOV类由四条指令构成:**movb**,**movw**,**movl**,**movq**,区别是操作数大小不同.

x86-64限制了MOV的两个操作数都不能都是内存地址,如果要实现,就找寄存器当工具人. 

大多数情况中,MOV指令只会更新目的操作数指定的那些寄存器字节或内存位置.唯一例外是,**movl**指令以寄存器作为目的时,会把该寄存器的高位4字节设置为0.这是由于x86-64采用的惯例,即任何为寄存器生成的32位值得指令都会把该寄存器的高位部分置为0.

常规的movq命令只能处理32位的源操作数,将其符号扩展得到64位. 而movbsq可以直接将64位数作为源操作数, 但目的只能是寄存器.

关于MOVZ和MOVS,这两个指令都是在将较小的源值复制到较大的目的时使用.

区别在于MOVZ使用0来填充,而MOVS使用符号位来填充.

在MOVS中有个指令cltq,用于将%eax符号扩展到%rax,等价于movslq %eax,%rax.



##### 练习题3.3

`movb $0xF, (%ebx)`	内存引用的寄存器必须是4bytes，改成`movb $0xF, (%rbx)`
`movb %al, %sl`	没有叫做`sl`的寄存器,只有`sil`和`spl`.
`movl %eax, %rdx`	寄存器大小不匹配



##### 练习题3.4

|     src_t     |  dest_t  |                             指令                             |
| :-----------: | :------: | :----------------------------------------------------------: |
|     long      |   long   |          movq (%rdi),%rax; <br />move %rax, (%rsi)           |
|     char      |   int    | 扩展符号到32位,<br />movsbl (%rdi), %eax;<br />movl %eax, (%rsi) |
|     char      | unsigned |         movsbl (%rdi), %eax;<br />movl %eax, (%rsi)          |
| unsigned char |   long   | unsigned, 零扩展. 零扩展没有扩展到64位的指令,32位就相当于64位的零扩展了.<br />movzbl (%rdi), %rax<br />movq %rax, (%rsi) |
|      int      |   char   |  区别在第二步<br />movl (%rdi), %eax<br />movb %al, (%rsi)   |



##### 练习题3.5

不考虑编译优化的话是:

```
void decode1(long *xp, long *yp, long *zp){
	long temp1 = *xp;
	long temp2 = *yp;
	long temp3 = *zp;
	*yp = temp1;
	*zp = temp2;
	*xp = temp3;
}
```



#### 3.4.4 压入和弹出栈数据

从%rbp寄存器中压一个四字入栈的指令`pushq`可以分解为:

```popq可以分解为:
subq $8, %rsp
push %rbp, (%rsp)
```

`popq`可以分解为:

```
movq (%rsp), %rax
addq %$8, %rsp
```



#### 3.5.3 移位操作

移位量可以是一个立即数,或者放在单字节寄存器%cl上.

| leaq 7 (%rax, %rax, 8), %rdx | `x + 8x + 7` |
| ---------------------------- | ------------ |
|                              |              |

##### 练习3.9

```
// x in %rdi, n in %rsi
shift_left4_rightn:
    movq %rdi, %rax;
    salq  $4, %rax     # x <<= 4
    movq %esi, %ecx;
    sarq  %cl, %rax    # x >>= n
```

##### 练习3.10

```
long t1 = x | y;
long t2 = t1 >> 3;
long t3 = ~t2;
long t4 = z - t3;
```

##### 练习3.11:

用于置0.比move开销小.



#### 3.5.5 特殊的算术操作

`imulq`和`mulqs`: "单操作数"乘法指令,用于处理128位的乘积.其中一个参数必须在%rax中.结果用%rdx存高64位,用%rax存低64位.

`idivq`:这个是有符号数的除法指令, 操作数S是除数, 被除数固定使用%rax作为低64字节, %rdx作为高64字节. 除法进行完之后,商存储在%rax中, 而余数存储在%rdx中.

`cqto`: 这个指令没有操作数, 将%rdx的位设置为%rax的符号位



##### 练习3.12

把`cqto`改成把%rdx的位置为0;



#### 3.6.1条件码

1. CF 进位标志, 最近的操作使最高位产生进位
2. ZF 零标志, 最近的操作的结果得到0
3. SF 符号标志, 最近的操作结果是负数
4. OF 溢出标志, 最近的操作导致补码溢出,正负溢出都算



`CMP`和`TEST`只改变条件码,前者是减法,后者是与(检测正负0).

同时注意`CMP`的操作数与`SUB`是相反的.

`SET`和`JMP`都可以根据条件码进行判断操作.

##### 练习3.13

- ```
  cmpl  %esi, %edi
  setl  %al
  ```

  后缀 ‘l’ 和寄存器指示符表明是 32 位操作数，而且调用的是有符号的小于比较。所以 `data_t` 一定是 int 。

- ```
  cmpw  %si, %di
  setge %al
  ```

  后缀 ‘w’ 和寄存器指示符表明是 16 位操作数，而且调用的是有符号的大于等于。所以 `data_t` 一定是 short。

- ```
  cmpb  %sil, %dil
  setbe %al
  ```

  后缀 ‘b’ 和寄存器指示符表明是 8 位操作数，而且调用的是无符号小于等于。所以 `data_t` 一定是 unsigned char 。

- ```
  cmpq  %rsi, %rdi
  setne %al
  ```

  后缀 ‘q’ 和寄存器指示符表明是 64 位操作数，同时比较符号是 `!=` ，有符号、无符号和指针参数都是一样的。所以 `data_t` 可以是 long、unsigned long 或 char * 。



`JMP`三种用法:

1. `JMP .L1`  等于goto
2. `JMP *%rax ` 用%rax的值作为跳转目标
3. `JMP *(%rax) `以%rax的值来读地址,从内存中读出并且跳转.



##### 练习3.15

```
4003fa: 74 02    je    XXXXXX
4003fc: ff do    callq *%rax
```

> je 指令的目标为 `0x4003fc + 0x02 = 0x4003fe` 

```
40042f: 74 f4    je   XXXXXX
400431: 5d       pop  %rbp
```

> je 指令的目标为 `0x400431 - 12（0xf4是-12的一个字节的补码表示）= 0x400425` 

```
XXXXXX: 77 02    ja   400547
XXXXXX: 5d       pop  %rbp
```

> 跳转目标是绝对地址 `0x400547` 。根据字节编码，一定在距离 pop 指令 `0x2` 的地址处。所以，pop 指令地址为 `0x400547 - 0x2 = 0x400545` 。**注意，ja 指令的编码需要 2 个字节。**所以 ja 指令的地址为 `0x400543`处。

```
4005e8: e9 73 ff ff ff     jmp  XXXXXX
4005ed: 90                 nop
```

> 偏移量是 `0xffffff73` ，也就是 `-141` 。所以跳转目标为 `0x4005ed - 141 = 0x400560` 

##### 练习3.18

```
long test(long x, long y, longz) {
    long val = x + y + z;
    if (x < -3) {
        if (y < z)
            val = x * y;
        else
            val = y * z;
    } else if (x > 2) 
        val = x * z;
   return val;
}
```



##### 练习3.21

```
long test(long x, long y) {
    long val = 8 * x;
    if (y > 0) {
        if (x < y)
            val = y - x;
        else
            val = x & y;
    } else if (y <= -2)
        val = x + y;
    return val;
}
```

#### 3.6.7 循环

##### 练习3.23

A.`%rax` 存放 x ，`%rcx` 存放 y ，`%rdx` 存放 n 

B. 用`leaq`指令 实现+y和++;

##### while循环

while语句的通用形式如下:

```
while(test-expr):

​	body-statement
```



1. 第一种翻译方法,我们称之为`跳转到中间`,它执行一个无条件跳转跳到循环结尾处的测试,以此来执行初始的测试.

```
	goto test;

loop:

​	body-statement

test:

​	t=test-expr;

​	if(t)

​		goto loop;
```

2. 第二种翻译方法,我们称之为`guarded-go`,首先用条件分支,如果初始条件不成立就跳过循环,把代码变换为`do-while`循环.

```
t=test-expr;

if(!t)

​	goto done;

loop:

​	body-statement;

​	t=test-expr;

​	if(t)

​		goto loop;

done;
```



##### 练习3.24

```
long loop_while(long a, long b)
{
    long result = 1;
    while (a < b) {
        result = result * (a + b);
        a = a + 1 ;
    }
    return result;
}
```

##### 练习题3.26

1. `jmp`

2. ```
   long fun_a(unsigned long x) {
       long val = 0;
       while (x) {
           val ^= x;
           x >>= 1;
       }
       return val & 0x1;
   }
   ```

3. 奇偶校验

##### for循环:

```
for(init-expr;test-expr;update-expr)

​	body-statement
```

等价于

```
init-expr;

while(test-expr){

​	body-statement;

​	update-expr

}
```

GCC为for循环产生的代码时while循环的两种翻译之一.

##### 练习3.28

A.

```
long fun_b(unsigned long x) {
    long val = 0;
    long i;
    for (i = 64; i != 0; i--) {
        val = (val * 2) | (x & 0x1);
        x >>= 1;
    }
    return val;
}
```

B.因为是使用guarded-do生成的,而初始化为0x40,一定满足,所以没必要测试.

C.reverse

##### 练习3.29

A. 导致i++无法执行,进入死循环.

B. 用goto跳过body-statement.

#### 3.6.8 switch语句

swtich 语句通过使用`跳转表`这种数据结构使得实现更加高效.\

GCC扩展了C语言, 加入了&&运算符用来取得指向标号的指针, 然后组成一个指针数组. 这样就可以用测试的值运算后得到的值直接进行索引来跳转.

` jmp *.L4(, %rsi, 8)`

跳转表:

```
.L4:
    .quad    .L3
    .quad    .L8
    .quad    .L5
    .quad    .L6
    .quad    .L7
```

##### 练习3.30

分析汇编:

```
# void switch2(long x, long *dest)
# x in %rdi
switch2:
    addq    $1, %rdi    # x = x + 1 ，所以 x 的最小值是 -1    
    cmpq    $8, %rdi    # 7结束   
    ja      .L2         # 超过 8 就跳转到 L2，所以 L2 相当于 default   
    jmp     *.L4(, %rdi, 8)    # 没有超过 8 就进入跳转表
```

##### 练习3.31

```
void switcher(long a, long b, long c, long *dest)
{
    long val;
    switch(a) {
    case 5:     /* Case A */
        c = b ^ 15;
        /* Fall through */
    case 0:     /* Case B */
        val = c + 112;
        break;
    case 2:     /* Case C */
    case 7:     /* Case D */
        val = (c + b) << 2;
        break;
    case 4:     /* Case E */
        val = a;
        break;
    default:
        val = b;
    }
    *dest = val;
}
```



#### 3.7过程

过程是软件中一种很重要的抽象.它提供了一种封装代码的方式,用一组指定的参数和一个可选的返回值实现了某种功能.过程在不同的语言中的表现形式不同, 比如函数, 方法等.

假设过程P调用过程Q:

- 传递控制: 在进入过程Q的时候,程序计数器必须被设置为Q的代码的初始地址,然后在返回时,要把程序计数器设置为P中调用Q后面那条指令的地址.
- 传递数据: P必须能向Q提供一个或多个参数,Q也能返回一个值.
- 分配和释放内存: Q可能需要为局部变量分配内存,返回时释放内存.

##### 3.7.1 运行时栈

C语言过程调用机制的一个关键特征在于使用了栈数据结构提供的后进先出的内存管理原则.

##### 3.7.3 数据传送

其实就是调用规则.

| 操作数大小 | 参数数量 |      |      |      |      |      |
| :--------: | :------: | :--: | :--: | :--: | :--: | ---- |
|            |    1     |  2   |  3   |  4   |  5   | 6    |
|     64     |   %rdi   | %rsi | %rdx | %rcx | %r8  | %r9  |
|     32     |   %edi   | %esi | %edx | %ecx | %r8d | %r9d |
|     16     |   %di    | %si  | %dx  | %cx  | %r8w | %r9w |
|     8      |   %dil   | %sil | %dl  | %cl  | %r8b | %r9b |

多于6个参数的放栈上.

##### 练习3.33

根据 size得知 sizeof(a)+sizeof(b)=6

所以一个为4,一个为2.且4扩8,2变1.

`int procprob(int a, short b, long *u, char *v)`
`int procprob(int b, short a, long *v, char *u)`

#### 3.7.5 寄存器中的局部存储空间

根据惯例,寄存器`%rbx`,`%rbp`和`%r12~%r15`被划分为`被调用者保存寄存器`.

所有其他的寄存器,除了栈指针`%rsp`,都分类为`调用者保存寄存器`



##### 练习3.34

A.局部值 a0 ~ a5 分别保存被调用者保存寄存器 %rbx、%r15、%r14、%13、%12 和 %rbp。

B.局部值 a6 和 a7 存放在栈中相对于栈指针偏移量为 0 和 8 的地方。

C. 因为用于存临时变量的寄存器只有6个. 

##### 练习3.35

寄存器保存参数x的值

```
long rfun(unsigned long x){
    if( x == 0 ){
        return return 0;
    }
    unsigned long nx = x >> 2;
    long rv = rfun(nx);
    return x + rv;
}
```

#### 3.8 数组分配和方问

#### 3.8.1 基本原则

假设E是一个int型的数组,而我们想计算E[i],在此,E的地址存放在寄存器%rdx中,而i存放在寄存器%rcx中.内存引用指令为:

> movl (%rdx,%rcx,4),%eax

#### 3.9.1 结构

类似于数组的实现,结构的所有组成部分都存放在内存中一段连续的区域内,而指向结构的指针就是结构第一字节的地址.

rp->width等价于表达式(*rp).width.

结构的各个字段的选取完全是在编译时处理的.机器代码不包含关于字段声明或字段名字的信息.

##### 练习3.42

```
long fun(struct ELE *ptr){
    long value = 0;
    while(ptr!=NULL){
        value += ptr->v;
        ptr= ptr->p;
    }
    return value;
}
```

#### 3.9.2联合

联合的空间始终等于其中最大的元素所占据的空间. 联合的一个优点是, 以不同的数据类型去访问数据的时候, 位级表示是一样的.

如果数据结构中存在很多互斥的数据,使用联合能够节省非常大的空间.

##### 练习3.43

|         expr         | type  |                             代码                             |
| :------------------: | :---: | :----------------------------------------------------------: |
|      `up->t1.u`      | long  |            `movq (%rdi), %rax movq %rax, (%rsi)`             |
|      `up->t1.v`      | short |             `movw 8(%rdi), %ax movw %ax, (%rsi)`             |
|     `&up->t1.w`      | char* |              `addq $10, %rdi movq %rdi, (%rsi)`              |
|      `up->t2.a`      | int*  |                     `movq %rdi, (%rsi)`                      |
| `up->t2.a[up->t1.u]` |  int  | `movq (%rdi), %rax movl (%rdi, %rax, 4), %eax movl %eax, (%rsi)` |
|     `*up->t2.p`      | char  |    `movq 8(%rdi), %rax movb (%rax), %al movb %al, (%rsi)`    |

#### 3.9.3 数据对齐

对齐限制简化了形成处理器和内存系统之间接口的硬件设计.

##### 练习3.44

A. `struct P1 {int i; char c; int j; char d};`

|  i   |  c   |  j   |  d   | 总共 | 对齐 |
| :--: | :--: | :--: | :--: | :--: | :--: |
|  0   |  4   |  8   |  12  |  16  |  4   |

B. `struct P2 {int i; char c; char d; long j};`

|  i   |  c   |  j   |  d   | 总共 | 对齐 |
| :--: | :--: | :--: | :--: | :--: | :--: |
|  0   |  4   |  5   |  8   |  16  |  8   |

C. `struct P3 {short w[3]; char c[3]};`

|  w   |  c   | 总共 | 对齐 |
| :--: | :--: | :--: | :--: |
|  0   |  6   |  10  |  2   |

D. `struct P4 {short w[5]; char *c[3]};`

|  w   |  c   | 总共 | 对齐 |
| :--: | :--: | :--: | :--: |
|  0   |  16  |  40  |  8   |

E. `struct P5 {struct P3 a[2]; struct P2 t};`

|  a   |  t   | 总共 | 对齐 |
| :--: | :--: | :--: | :--: |
|  0   |  24  |  40  |  8   |

##### 练习3.45

A.

|  字段  |  a   |  b   |  c   |  d   |  e   |  f   |  g   |  h   |
| :----: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  大小  |  8   |  2   |  8   |  1   |  4   |  1   |  8   |  4   |
| 偏移量 |  0   |  8   |  16  |  24  |  28  |  32  |  40  |  48  |

B. 56 个字节长。

C. 从大往小排 40

#### 3.10.1 理解指针

- 每个指针都对应一个类型.这个类型表明该指针指向的是哪一类对象.
  - 指针类型不是机器代码中的一部分
  - 它们是C语言提供的一种抽象,帮助程序员避免寻址错误
- 每个指针都有一个值
  - 这个值是某个指定类型的对象的地址
  - 特殊的NULL(0)值表示该指针没有指向任何地方
- 指针用'&'运算符创建
  - leaq指令是设计用来计算内存引用的地址的.
  - &运算符的机器代码实现常常用这条指令来计算表达式的值
- *操作符用于间接引用指针.
  - 间接引用是用内存引用来实现的
- 数组与指针紧密联系
  - 数组引用(a[3])与指针运算和间接引用(*(a+3))有一样的效果
- 将指针从一种类型强制转换成另一种类型,只改变它的类型,而不改变它的值.
- 指针也可以指向函数.
  - 函数指针的值是该函数机器代码表示中第一条指令的地址.

</details>

<details>
<summary> 第四章 处理器体系结构</summary>

## 处理器体系结构

`指令集体系结构`(Instruction-Set Architecture, ISA)

### 4.1 Y86-64指令集体系结构

1. 15个寄存器, 不包括%r15. 这样内部寻址可以用0-15来选择寄存器. %rsp依然用作栈指针
2. 每个寄存器都存储64位=8字节值, 机器里操作的所有值也都是8字节长
3. 三个一位的条件码: ZF SF 和 OF
4. 程序计数器 PC
5. 有一个状态码 Stat 用于表示程序状态
6. DMEM 内存, 这用虚拟地址来引用

#### 4.1.2 Y86-64指令

只包括8字节整数操作

- `movq`. irmovq, rrmovq, mrmovq, rmmovq. 第一个字母表示源, 第二个字母表示目标. i = 立即数, r = 寄存器, m = 内存
  - 内存引用方式是简单的基址和偏移量形式. 
- 运算指令有四个, addq, subq, andq, xorq, 只能对寄存器进行操作. 这些指令会同时设置条件码.
- 7个跳转指令, jmp, jle, jl, je, jne, jge, jg
- 6个条件传送指令, cmovle, cmovl, cmove, cmovne, cmovge, cmovg. 
- call 和 ret 
- pushq 和 popq
- halt 停止指令的执行, 导致处理器停止,状态码会设置成HLT.

#### 4.1.3 指令编码

每条指令的第一个字节表明指令的类型.这个字节分为两部分,每部分4位;高四位是代码部分,低四位是功能部分.

几个指令类的具体代码对应关系如下:

| 整数操作 |          | 分支指令 |          |      |          | 传送指令 |          |        |          |
| :------: | :------: | :------: | :------: | :--: | :------: | :------: | :------: | :----: | :------: |
|   指令   | 字节编码 |   指令   | 字节编码 | 指令 | 字节编码 |   指令   | 字节编码 |  指令  | 字节编码 |
|   addq   |    60    |   jmp    |    70    | jne  |    74    |  rrmovq  |    20    | cmovne |    24    |
|   subq   |    61    |   jle    |    71    | jge  |    75    |  cmovle  |    21    | cmovge |    25    |
|   andq   |    62    |    jl    |    72    |  jg  |    76    |  cmovl   |    22    | cmovg  |    26    |
|   xorq   |    63    |    je    |    73    |      |          |  cmove   |    23    |        |          |

寄存器的编码是:

|  寄存器  | 编码 |
| :------: | :--: |
|   %rax   |  0   |
|   %rcx   |  1   |
|   %rdx   |  2   |
|   %rbx   |  3   |
|   %rsp   |  4   |
|   %rbp   |  5   |
|   %rsi   |  6   |
|   %rdi   |  7   |
| %r8-%r14 | 8-E  |
| 无寄存器 |  F   |

所有整数采用小端法格式.当指令按照反汇编格式数写时,这些字节就以相反的顺序出现.

指令集的一个 重要性质就是字节编码必须有唯一的解释.

##### 练习4.1

```
0x100 30 F3 0F 00 00 00 00 00 00 00
0x10A 20 31
0x10C 40 13 fd ff ff ff ff ff ff ff
0x116 60 31
0x118 70 0C 01 00 00 00 00 00 00
```

#### 4.1.4 Y86-64异常

状态码stat对应的值:

|  值  | 名称 |     含义      |
| :--: | :--: | :-----------: |
|  1   | AOK  |   正常操作    |
|  2   | HLT  | 执行了HLT命令 |
|  3   | ADR  |   非法地址    |
|  4   | INS  |   非法指令    |

#### 4.1.5 Y86-64程序

以"."开头的词是`汇编器伪指令`.它们告诉汇编器调整地址,以便在那里产生代码或插入一些数据.

##### 练习题4.4

```
long rsum(long *start, long count)
start in %rdi, count in %rsi

rsum:
    xorq %rax, %rax         %rax置0
    test %rsi, %rsi         测试count
    jle  L2                 小于等于0则跳转到L2

    pushq %rbp
    movq (%rdi), %rbx       把start的值保存到%rbp中
    addq $8, %rdi           准备参数 start + 1
    subq $1, %rsi           准备参数 count - 1
    callq rsum              调用新过程
    addq %rbx, %rax         将保存的start的值加到返回值上
    popq %rbx               恢复%rbp的值
    ret                     返回%rax
  .L2
    rep; ret                返回0, 直接返回0的情况下, 没有用到%rbp, 所以也无需弹栈
```

修改部分加**表示:

```
long rsum(long *start, long count)
start in %rdi, count in %rsi

rsum:
    xorq %rax, %rax         %rax置0
**  andq %rsi, %rsi         测试count
    jle  L2                 小于等于0则跳转到L2

    pushq %rbp
**  mrmovq (%rdi), %rbx     把start的值保存到%rbp中
**  irmovq $1, %r8          准备常量1到%r8寄存器
**  irmovq $8, %r9          准备常量8到%r9寄存器
**  addq %r9, %rdi          准备参数 start + 1
**  subq %r8, %rsi          准备参数 count - 1
    callq rsum              调用新过程
    addq %rbx, %rax         将保存的start的值加到返回值上
    popq %rbx               恢复%rbp的值
    ret                     返回%rax
  .L2
    rep; ret                返回0, 直接返回0的情况下, 没有用到%rbp, 所以也无需弹栈
```

##### 练习题4.5

压入%rsp的原始值,因为减为0

##### 练习题4.6

弹出原来的值.

### 4.2 HCL

在HCL中,多路复用函数是用`情况表达式`来描述的

```
[
    select1 : expr1;
    select2 : expr2;
    select3 : expr3;
        .
        .
        .
    selectN : exprN;
]
```

集合存储器时钟 暂不总结

### 4.3 Y86-64

处理的阶段:

- 取指
  - 从内存中读取指令字节.地址为程序计数器(PC)的值
  - 从指令中抽取指令指示部分的两个四位部分,称为icode(指令代码)和ifun(指令功能
  - 它可能取出一个寄存器指示符字节,指明一个或两个寄存器操作数指示符rA和rB.
  - 它还可能取出一个8字节常数字valC.
  - 它按顺序方式计算当前指令的下一条指令的地址valP.
- 译码
  - 从寄存器文件中读入最多两个操作数,得到值valA和valB
- 执行
  - ALU要么执行指令指明的操作,计算内存引用的有效地址,要么增加或减少栈指针,得到的值为valE.
  - 也可能设置条件码,根据条件传送指令更新目标寄存器,以及决定跳转.
- 访存
  - 这个阶段可以将数据写入内存, 或者从内存读出数据, 读出的值为valM.
- 写回
- 更新PC

##### OPq系列指令和rrmovq,irmovq指令

这一系列指令无需操作内存, 来看一看三者的执行过程:

|  阶段  |                          Opq rA, rB                          |                        rrmovq rA, rB                         |                         irmovq V, rB                         |
| :----: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 取指令 | 从程序计数器的地址中取出icode:ifun, 由于是单字节, 下一条程序计数器的地址 +1: M1[PC] => icode:ifun 取单字节, 表示两个寄存器, 下一条程序计数器的地址 +1: M1[PC+1] => rA : rB 取完了两字节的指令, 得到下一条程序计数器的地址是 PC + 2, 此时知道了valP的值: PC + 2 => valP | 由于rrmovq和OPq操作的都是两个寄存器, 因此这一阶段和OPq相同.  | irmovq相比前两个操作, 除了读入之前两个操作的两字节之外, 还需要读入额外的8字节操作数valC: M8[PC+2] => valC valP => PC + 10 |
|  译码  |    从寄存器中读出valA和valB: R[rA] => valA R[rB] => valB     |   由于rrmovq只需要知道rA的值,因此只取rA的值: R[rA] => valA   |        由于valA是不用操作的, valB是目标, 所以无需译码        |
|  执行  | 将valB 和 valA 送入ALU进行操作, 得到 valE: valA OP valB => valE 同时我们的Y86还会在此时设定条件码: Set CC | 此时由于无需计算valA, 实际的操作就是valA + 0, 不改变valA: valA + 0 => valE | 无需记性计算, 只是把valC 放入 valB, 所以valE就是valC: valC + 0 => valE |
|  访存  |                    仅操作寄存器, 无需访存                    |                    仅操作寄存器, 无需访存                    |                        这个也无需访存                        |
|  写回  |              要把valE写入到 rB中: valE => R[rB]              |              要把valE写入到 rB中: valE => R[rB]              | 要把valE写入到 rB中: valE => R[rB], 这三条操作都是对rB操作, 所以是一样的 |
| 更新PC |                  更新程序计数器: valP => PC                  |                  更新程序计数器: valP => PC                  |   同样需要更新程序计数器: valP => PC, 这条指令长度是10字节   |

##### rmmovq 和 mrmovq 指令

最大的特点的带上了内存读写, 也就是存在访存操作. 因为有了访存操作, 在之前需要计算出内存地址

|  阶段  |                       rmmovq rA, D(rB)                       |                       mrmovq D(rB), rA                       |
| :----: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 取指令 | 两个取指令都是一样的: 取指令: icode:ifun <= M1[PC] 取寄存器: rA:rB <= M1[PC+1], 注意mrmovq解释寄存器的顺序相反 取偏移量常数: valC <= M1[PC+2] 指令是10字节长度, 计算出新的PC地址: valP = PC + 10 |                                                              |
|  译码  | 取出valA和valB, 因为valA是要写入的值, valB是基地址, 都要用到 | 只要取出valB即可, 因为valB的值是基地址, 要计算出实际的内存地址. rA则是目标对象 ,无需取出valA. |
|  执行  | 两者这里是一样的, 都需要通过valC和valB计算出实际内存地址: valE = valB + valC |                                                              |
|  访存  |  这条指令需要把valA写入valE对应的内存地址: valA => M8[valE]  |  这条指令先要从计算出的内存地址中取出valM M8[valE] => valM   |
|  写回  |                    这个指令无需写回寄存器                    |          将刚刚取出的valM写入寄存器: valM => R[rA]           |
| 更新PC |                          PC <= valP                          |                                                              |



##### pushq 和 popq 指令

多了操作%rsp寄存器的操作

|  阶段  |                            pushq                             |                             popq                             |
| :----: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 取指令 | 两个取指令都是一样的: 取指令: icode:ifun <= M1[PC] 取寄存器: rA:rB <= M1[PC+1], 注意mrmovq解释寄存器的顺序相反 指令是2字节长度, 计算出新的PC地址: valP = PC + 2 |                                                              |
|  译码  | pushq的译码要注意, 在指令里取出来的rB是F, 但是这里实际操作需要从rA中取到valA, 因为这是要压栈的数据. 此外还自动从当前的%rsp中取出当前的栈地址, 当做valB M8[rA] => valA M8[%rsp] => valB | popq这里更特别, 由于是从栈里取数, 现在寄存器中的值是什么无需关心, 这里取两次%rsp的值分别放入valA和valB: R[%rsp] => valA R[%rsp] => valB |
|  执行  | 想一想之前的要求, 在写入内存之后, 更新栈指针. 要先计算出来写入内存之后新的栈顶指针. 由于栈顶指向的是第一个元素, 所以要算出来新的栈顶地址: valB – 8 => valE | 对比一下pushq, 当前的%rsp指向的是当前的栈顶, 要先计算出来弹栈之后的下一个栈顶地址: valB + 8 => valE |
|  访存  | 访存对于两个指令来说很关键, 压栈就是将valA压入新的栈顶对应的地址: valA => M8[valE] | 弹栈这里要注意, 是从原来的栈顶, 也就是valA中读出数据, 不是valE M8[valA] => valM |
|  写回  | 这里要注意, 写回的时候写哪个? 显然是更新过的栈指针valE valE => R[%rsp] | 这里要注意, 写回栈指针用的也是更新过的栈指针valE valE => R[%rsp] 此外由于是弹栈, 还需要将读取的valM写入到rA寄存器中来: valM => R[rA] 注意这是有顺序的, valM后发生 |
| 更新PC |           这2个指令都是2字节, 所以 newPC <= PC + 2           |                                                              |

##### call 和 ret

 由于跳转的本质就是更新程序计数器, 所以在更新PC的阶段, 会根据CC码来判断要将跳转的地址写入PC, 还是仅仅更新PC到下一条指令的地址.

| 阶段   | jxx Dest                                                     | call Dest                                                    | ret                                                          |
| ------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 取指令 | M1[PC] => icode:ifun valC => M8[PC+1] 取跳转地址 valP = PC +9, 9字节长的指令 | 与jxx 指令完全相同: M1[PC] => icode:ifun valC => M8[PC+1] valP = PC +9, 9字节长的指令 | ret指令是1字节指令, 无需取常数: M1[PC] => icode:ifun valP = PC +1 |
| 译码   | jxx无需译码, 因为不需要操作寄存器和内存, 要跳转的地址valC和下一条指令地址valP均已知 | call包含了压栈操作, 按照压栈的流程, valA由于没有, 就用不到, 但是要把当前栈地址取出来: R[%rsp] => valB | ret包含了弹栈操作, 所以是valA和valB都要设置成%rsp R[%rsp] => valA R[%rsp] => valB |
| 执行   | jxx的执行阶段会根据跳转功能, 检测对应的条件码, 然后更新Cnd码 Cond(CC, ifun) => Cnd 信号 | 压栈, 所以栈指针-8 valE = valB – 8                           | 弹栈, 栈指针+8 valE = valB + 8                               |
| 访存   | 完全不需要访存                                               | 压栈, 将下一条地址压入栈中, 下一条地址是已经计算出的valP valP => M8[%rsp] | 弹栈, 用原始的栈指针去读valM, valM就是将跳转的地址 valM = M8[valA] |
| 写回   | 也无需写回                                                   | 更新%rsp 为 -8 之后的数字 valE => R[%rsp]                    | 将栈地址更新到 +8 的地址, 由于不涉及其他寄存器, 无需将值写入其他寄存器, 只更新栈指针寄存器: valE => R[%rsp] |
| 写回   | 这里很关键, 根据Cnd信号, 决定是把下一条地址写入PC(即不跳转), 还是把常数地址valC写入PC(即执行跳转): Cnd? valC: valP => PC | 由于压完了当前下一条地址, 下边就要跳转了, 所以是把常数valC 写入 PC: valC => PC | 从内存中读取了要跳转的地址 valM, 很显然要把valM 写入 PC: valM => PC |

### 4.3.2 SEQ硬件结构

主要是看图理解.

### 4.3.3 SEQ的时序

SEQ的实现包括组合逻辑和两种存储器设备:时钟寄存器(程序计算器和条件码寄存器),随机访问存储器(寄存器文件、指令内存和数据内存)

组合逻辑不需要任何时序或控制--只要输入变化了,值就通过逻辑门网络传播.

由于指令内存只用来读指令,因此我们可以将这个单元看成是组合逻辑.

现在还剩四个硬件的单元需要对它们的时序进行明确的控制--程序计数器.条件码寄存器,数据内存和寄存器文件.

要控制处理器中活动的时序,只需要寄存器和内存的时钟控制.

原则: 绝不回读

### 4.4 流水线的通用原理

流水线化的一个重要特性就是提高了系统的吞吐量,也就是单位时间内执行的指令总数,不过它也会轻微地增加延迟,也就是执行一个指令所需要的时间.

流水线的局限性:

- 不一致的划分
- 流水线过深,收益反而下降

### 4.5 Y86-64的流水线实现

- SEQ+: 重新安排计算阶段.

- 插入流水线寄存器

- 对信号进行重新排列和标号

- 预测下一个PC

- 流水线冒险

</details>
<details>
<summary> 第五章 优化程序性能</summary>
</details>

> 编译器必须很小心地对程序只使用安全的优化,也就是说对于程序可能遇到的所有可能的情况,在C语言标准提供的保证之下,优化后得到的程序和未优化的版本有一样的行为.

#### 5.1 优化编译器的能力和局限性

- 两个指针可能指向同一个内存位置的情况称为内存别名使用.

例如:

```
x=1000;y=3000;

*q=y; /*3000*/

*p=x; /*1000*/

t1=*q; /*1000 or 3000*/
```

如果编译器不能确定两个指针是否指向同一个位置,就必须假设什么情况都有可能,这就限制了可能的优化策略.

##### 练习题5.1

如果xp=yp,则无论传入参数值是什么,都会清零.

- 第二个妨碍优化的因素是函数调用.

假设函数有副作用,修改了全局程序状态的一部分.

大多数编译器不会试图判断一个函数是否没有副作用,如果没有,就可能被优化成像fun2中的样子.相反,编译器会假设最糟的情况,并保持所有的函数调用不变.

#### 5.2 表示程序性能

引入量度标准`每元素的周期数`(CPE),作为一种表示程序性能并知道我们改进代码的方法.

提到了`循环展开`的一个技术.大概意思就是在一个循环进行更多的迭代.

#### 5.4 消除循环的低效率

例如书上的例子:

```
#define IDENT 0
#define OP +

void combine1(vec_ptr v,data_t *dest){
    long i;
    *dest = IDENT;

    for (i = 0; i < vec_length(v);i++) {
        data_t val;
        //读取第i的索引的值到val中
        get_vec_element(v, i, &val);
        //将val根据OP累计到*dest中
        *dest = *dest OP val;
    }
}
```

里面循环的vec_length(v)移动到循环外.

```
void combine2(vec_ptr v,data_t *dest){
    //用局部变量存储向量长度
    long length = vec_length(v);

    long i;
    *dest = IDENT;

    for (i = 0; i < length;i++) {
        data_t val;
        get_vec_element(v, i, &val);
        *dest = *dest OP val;
    }
}
```

效率就提高了不少.

这个优化是一类常见的优化的一个例子,称为`代码移动`.这类优化包括识别要执行多次(例如在循环中)但是计算结果不会改变的计算.

这个示例说明了编程时一个常见的问题,**一个看上去无足轻重的代码片段有隐藏的渐进低效率.**

#### 5.4 消除循环的低效率

例如书上的例子:

```
#define IDENT 0
#define OP +

void combine1(vec_ptr v,data_t *dest){
    long i;
    *dest = IDENT;

    for (i = 0; i < vec_length(v);i++) {
        data_t val;
        //读取第i的索引的值到val中
        get_vec_element(v, i, &val);
        //将val根据OP累计到*dest中
        *dest = *dest OP val;
    }
}
```

里面循环的vec_length(v)移动到循环外.

```
void combine2(vec_ptr v,data_t *dest){
    //用局部变量存储向量长度
    long length = vec_length(v);

    long i;
    *dest = IDENT;

    for (i = 0; i < length;i++) {
        data_t val;
        get_vec_element(v, i, &val);
        *dest = *dest OP val;
    }
}
```

效率就提高了不少.

这个优化是一类常见的优化的一个例子,称为`代码移动`.这类优化包括识别要执行多次(例如在循环中)但是计算结果不会改变的计算.

这个示例说明了编程时一个常见的问题,**一个看上去无足轻重的代码片段有隐藏的渐进低效率.**

#### 5.5 减少调用过程

```
void combine3(vec_ptr v, data_t *dest) {
    long i;
    long length = vec_length(v);
    data_t *data = get_vec_start(v);
    //直接获取数组的首元素指针, 不再调用函数
    *dest=IDENT;
    for (i = 0; i < length; i++) {
        *dest = *dest OP data[i];
    }
}
```

这里书上提到了combine3把get_vec_element()函数调用提出来了,但是代码没有显示性能提升.

#### 5.6 消除不必要的内存引用

在这里解答上面的问题.

每次迭代时,积累变量的数值都要从内存读出再写入到内存.这样的读写很浪费,因为每次迭代开始时从dest读出来的值就是上次迭代最后写入的值.

```
void combine4(vec_ptr v, data_t *dest) {
    long i;
    long length = vec_length(v);
    data_t *data = get_vec_start(v);
    data_t acc = IDENT;
    for (i = 0; i < length; i++) {
        acc = acc OP ptr[i];
    }
    *dest = acc;
}
```

为了消除这种不必要的内存读写,combine4引入了一个临时变量来存储.性能有了明显提高.

</details>
### 第二章 信息的表示和处理



> 孤立的一个位不是非常有用.但是,当把位组合在一起,再加上某种解释,即赋予不同的可能位模式以含义,就能够表示任何有限集合的元素.

#### intro

计算机的表示法是用有限数量的位来对一个数字编码,因此,但结果太大以至于不能表示时,某些计算就会溢出.

整数的表示虽然只能编码一个相对较小的数值范围,但是这种表示是准确的;

而浮点数虽然可以编码一个较大的数值范围,但是这种表示只是近似的.

#### 2.1.2 字数据大小

每台计算机都有一个字长,指明**指针数据**的标称大小.因为虚拟地址是以这样的一个字来编码的,所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小.

使用确定大小的整数类型是程序员精确控制数据表示的最佳途径.其中包括ISO C99引入的int32_t和int64_t,分别为4字节和8字节.这样会有更好的移植性. 使用sizeof也是一种好方法.

#### 2.1.3 寻址和字节顺序

关于大小端的问题:

比如int x=0x1234567.

如果是大端法就是 01 23 45 67

小端法则是 67 45 23 01

大多数Intel兼容机都只有小端模式.

讲解程序代码: [show_byte.cpp](https://github.com/whhhite/skr_university_learning_record/blob/master/csapp/%E7%AC%AC%E4%BA%8C%E7%AB%A0/show_bytes.cpp)

##### 练习2.6:

len是不包括最后的\x00的.

##### 练习2.11:

inplace_swap这个函数是异或置换,所以中间值置0

#### 2.1.7 C语言中的位级运算

位级运算的一个常见应用是实现掩码运算，掩码是一个位模式。使用类似~0得到全1的掩码,这样的代码具有移植性.

##### 练习2.25:

length=0

0U-1=UMax,所以访问了非法地址. coredump

##### 练习2.26:

无符号数,小减大,会产生一个很大的无符号数.

#### 函数getpeername的安全漏洞

问题是由于数据类型的不匹配造成的:在一个地方是无符号数,另一个地方是有符号数.

##### 练习2.27

return (x+y)>=x 

##### 练习2.30

正溢出: x>=0 && y>=0 && (x+y)<0

负溢出: x<0 && y<0 && (x+y)>0

##### 练习2.32

x>0 y=INT_MIN,两者异号不判断溢出,但其实是溢出了.

[tsub_ok.cpp](https://github.com/whhhite/skr_university_learning_record/blob/master/csapp/%E7%AC%AC%E4%BA%8C%E7%AB%A0/show_bytes.cpp)

#### XDR库中的安全漏洞

问题是由于乘法溢出,导致复制的字节大于已分配的缓冲区的界限.

##### 练习2.37

由于uint64_t的强制类型转换,在asize这部分还不会溢出.

但是由于malloc的参数类型和是size_t,在这里还是会产生溢出.

应该修改成:

      uint64_t asize = ele_cnt * (uint64_t) ele_size;
      unsigned int asize2 = ele_cnt * ele_size;
      if (asize == asize2) {//执行分配 }
      else { //抛出异常}
#### 2.3.6 乘以常数

由于整数乘法比移位和加法的代价要大得多,许多C语言编译器试图以移位,加法和减法的组合消除很多整数乘以常数的情况.

如: x*14 则根据 14=2^3+2^2+2,编译器会重写成(x<<3)+(x<<2)+(x<<1)

##### 练习题2.42

见[div_16.cpp](https://github.com/whhhite/skr_university_learning_record/blob/master/csapp/%E7%AC%AC%E4%BA%8C%E7%AB%A0/div16.cpp)

##### 练习题2.46

A.对齐后得到结果是 0.00000000000000000000000[1100]

B.2^(-24)

C.运行了100个小时,有100 * 3600 * 10次,所以误差还是挺大的,大概0.343秒

D.差了686米

#### 2.4.2 IEEE浮点表示

V=(-1)^s × M × 2^E

将浮点数的位表示划分为三个字段

* 一个单独的符号位直接编码符号s
* k位的阶码字段 exp
* n位的小数字段frac

float中 s=1 k=8 n=23 

double中 s=1 k=11 n=52

分为三种情况:

1. 规格化的值

偏置值Bias=2^(k-1)-1

阶码的值 E=e-Bias

M=1+f,也叫做隐含的以1开头的表示

2. 非规划化的值

E=1-Bias

M=f

3. 特殊值

当阶码全为1,小数全为0则为无穷

小数非0时,则表示为NaN(Not a number)

#### 2.4.5 浮点运算

浮点加法有个最大的问题，就是不具有结合性，大数会把小的数字吃掉，这是因为舍入的原因。乘法也一样

##### 练习2.54

int转float 有可能被舍入,


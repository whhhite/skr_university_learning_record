## 处理器体系结构

`指令集体系结构`(Instruction-Set Architecture, ISA)

### 4.1 Y86-64指令集体系结构

1. 15个寄存器, 不包括%r15. 这样内部寻址可以用0-15来选择寄存器. %rsp依然用作栈指针
2. 每个寄存器都存储64位=8字节值, 机器里操作的所有值也都是8字节长
3. 三个一位的条件码: ZF SF 和 OF
4. 程序计数器 PC
5. 有一个状态码 Stat 用于表示程序状态
6. DMEM 内存, 这用虚拟地址来引用

#### 4.1.2 Y86-64指令

只包括8字节整数操作

* `movq`. irmovq, rrmovq, mrmovq, rmmovq. 第一个字母表示源, 第二个字母表示目标. i = 立即数, r = 寄存器, m = 内存
  * 内存引用方式是简单的基址和偏移量形式. 
* 运算指令有四个, addq, subq, andq, xorq, 只能对寄存器进行操作. 这些指令会同时设置条件码.
* 7个跳转指令, jmp, jle, jl, je, jne, jge, jg
* 6个条件传送指令, cmovle, cmovl, cmove, cmovne, cmovge, cmovg. 
* call 和 ret 
* pushq 和 popq
* halt 停止指令的执行, 导致处理器停止,状态码会设置成HLT.

#### 4.1.3 指令编码

每条指令的第一个字节表明指令的类型.这个字节分为两部分,每部分4位;高四位是代码部分,低四位是功能部分.

几个指令类的具体代码对应关系如下:

| 整数操作 |          | 分支指令 |          |      |          | 传送指令 |          |        |          |
| :------: | :------: | :------: | :------: | :--: | :------: | :------: | :------: | :----: | :------: |
|   指令   | 字节编码 |   指令   | 字节编码 | 指令 | 字节编码 |   指令   | 字节编码 |  指令  | 字节编码 |
|   addq   |    60    |   jmp    |    70    | jne  |    74    |  rrmovq  |    20    | cmovne |    24    |
|   subq   |    61    |   jle    |    71    | jge  |    75    |  cmovle  |    21    | cmovge |    25    |
|   andq   |    62    |    jl    |    72    |  jg  |    76    |  cmovl   |    22    | cmovg  |    26    |
|   xorq   |    63    |    je    |    73    |      |          |  cmove   |    23    |        |          |

寄存器的编码是:

|  寄存器  | 编码 |
| :------: | :--: |
|   %rax   |  0   |
|   %rcx   |  1   |
|   %rdx   |  2   |
|   %rbx   |  3   |
|   %rsp   |  4   |
|   %rbp   |  5   |
|   %rsi   |  6   |
|   %rdi   |  7   |
| %r8-%r14 | 8-E  |
| 无寄存器 |  F   |

所有整数采用小端法格式.当指令按照反汇编格式数写时,这些字节就以相反的顺序出现.

指令集的一个 重要性质就是字节编码必须有唯一的解释.

##### 练习4.1

```
0x100 30 F3 0F 00 00 00 00 00 00 00
0x10A 20 31
0x10C 40 13 fd ff ff ff ff ff ff ff
0x116 60 31
0x118 70 0C 01 00 00 00 00 00 00
```

#### 4.1.4 Y86-64异常

状态码stat对应的值:

|  值  | 名称 |     含义      |
| :--: | :--: | :-----------: |
|  1   | AOK  |   正常操作    |
|  2   | HLT  | 执行了HLT命令 |
|  3   | ADR  |   非法地址    |
|  4   | INS  |   非法指令    |

#### 4.1.5 Y86-64程序

以"."开头的词是`汇编器伪指令`.它们告诉汇编器调整地址,以便在那里产生代码或插入一些数据.

##### 练习题4.4

```
long rsum(long *start, long count)
start in %rdi, count in %rsi

rsum:
    xorq %rax, %rax         %rax置0
    test %rsi, %rsi         测试count
    jle  L2                 小于等于0则跳转到L2

    pushq %rbp
    movq (%rdi), %rbx       把start的值保存到%rbp中
    addq $8, %rdi           准备参数 start + 1
    subq $1, %rsi           准备参数 count - 1
    callq rsum              调用新过程
    addq %rbx, %rax         将保存的start的值加到返回值上
    popq %rbx               恢复%rbp的值
    ret                     返回%rax
  .L2
    rep; ret                返回0, 直接返回0的情况下, 没有用到%rbp, 所以也无需弹栈
```

修改部分加**表示:

```
long rsum(long *start, long count)
start in %rdi, count in %rsi

rsum:
    xorq %rax, %rax         %rax置0
**  andq %rsi, %rsi         测试count
    jle  L2                 小于等于0则跳转到L2

    pushq %rbp
**  mrmovq (%rdi), %rbx     把start的值保存到%rbp中
**  irmovq $1, %r8          准备常量1到%r8寄存器
**  irmovq $8, %r9          准备常量8到%r9寄存器
**  addq %r9, %rdi          准备参数 start + 1
**  subq %r8, %rsi          准备参数 count - 1
    callq rsum              调用新过程
    addq %rbx, %rax         将保存的start的值加到返回值上
    popq %rbx               恢复%rbp的值
    ret                     返回%rax
  .L2
    rep; ret                返回0, 直接返回0的情况下, 没有用到%rbp, 所以也无需弹栈
```

#####  练习题4.5

压入%rsp的原始值,因为减为0

#####  练习题4.6

弹出原来的值.

### 4.2 HCL

在HCL中,多路复用函数是用`情况表达式`来描述的

```
[
    select1 : expr1;
    select2 : expr2;
    select3 : expr3;
        .
        .
        .
    selectN : exprN;
]
```

集合存储器时钟 暂不总结

### 4.3 Y86-64

处理的阶段:

* 取指
  * 从内存中读取指令字节.地址为程序计数器(PC)的值
  * 从指令中抽取指令指示部分的两个四位部分,称为icode(指令代码)和ifun(指令功能
  * 它可能取出一个寄存器指示符字节,指明一个或两个寄存器操作数指示符rA和rB.
  * 它还可能取出一个8字节常数字valC.
  * 它按顺序方式计算当前指令的下一条指令的地址valP.
* 译码
  * 从寄存器文件中读入最多两个操作数,得到值valA和valB
* 执行
  * ALU要么执行指令指明的操作,计算内存引用的有效地址,要么增加或减少栈指针,得到的值为valE.
  * 也可能设置条件码,根据条件传送指令更新目标寄存器,以及决定跳转.
* 访存
  * 这个阶段可以将数据写入内存, 或者从内存读出数据, 读出的值为valM.
* 写回
* 更新PC

##### OPq系列指令和rrmovq,irmovq指令

这一系列指令无需操作内存, 来看一看三者的执行过程:

|  阶段  |                          Opq rA, rB                          |                        rrmovq rA, rB                         |                         irmovq V, rB                         |
| :----: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 取指令 | 从程序计数器的地址中取出icode:ifun, 由于是单字节, 下一条程序计数器的地址 +1: M1[PC] => icode:ifun 取单字节, 表示两个寄存器, 下一条程序计数器的地址 +1: M1[PC+1] => rA : rB 取完了两字节的指令, 得到下一条程序计数器的地址是 PC + 2, 此时知道了valP的值: PC + 2 => valP | 由于rrmovq和OPq操作的都是两个寄存器, 因此这一阶段和OPq相同.  | irmovq相比前两个操作, 除了读入之前两个操作的两字节之外, 还需要读入额外的8字节操作数valC: M8[PC+2] => valC valP => PC + 10 |
|  译码  |    从寄存器中读出valA和valB: R[rA] => valA R[rB] => valB     |   由于rrmovq只需要知道rA的值,因此只取rA的值: R[rA] => valA   |        由于valA是不用操作的, valB是目标, 所以无需译码        |
|  执行  | 将valB 和 valA 送入ALU进行操作, 得到 valE: valA OP valB => valE 同时我们的Y86还会在此时设定条件码: Set CC | 此时由于无需计算valA, 实际的操作就是valA + 0, 不改变valA: valA + 0 => valE | 无需记性计算, 只是把valC 放入 valB, 所以valE就是valC: valC + 0 => valE |
|  访存  |                    仅操作寄存器, 无需访存                    |                    仅操作寄存器, 无需访存                    |                        这个也无需访存                        |
|  写回  |              要把valE写入到 rB中: valE => R[rB]              |              要把valE写入到 rB中: valE => R[rB]              | 要把valE写入到 rB中: valE => R[rB], 这三条操作都是对rB操作, 所以是一样的 |
| 更新PC |                  更新程序计数器: valP => PC                  |                  更新程序计数器: valP => PC                  |   同样需要更新程序计数器: valP => PC, 这条指令长度是10字节   |

##### rmmovq 和 mrmovq 指令

最大的特点的带上了内存读写, 也就是存在访存操作. 因为有了访存操作, 在之前需要计算出内存地址

|  阶段  |                       rmmovq rA, D(rB)                       |                       mrmovq D(rB), rA                       |
| :----: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 取指令 | 两个取指令都是一样的: 取指令: icode:ifun <= M1[PC] 取寄存器: rA:rB <= M1[PC+1], 注意mrmovq解释寄存器的顺序相反 取偏移量常数: valC <= M1[PC+2] 指令是10字节长度, 计算出新的PC地址: valP = PC + 10 |                                                              |
|  译码  | 取出valA和valB, 因为valA是要写入的值, valB是基地址, 都要用到 | 只要取出valB即可, 因为valB的值是基地址, 要计算出实际的内存地址. rA则是目标对象 ,无需取出valA. |
|  执行  | 两者这里是一样的, 都需要通过valC和valB计算出实际内存地址: valE = valB + valC |                                                              |
|  访存  |  这条指令需要把valA写入valE对应的内存地址: valA => M8[valE]  |  这条指令先要从计算出的内存地址中取出valM M8[valE] => valM   |
|  写回  |                    这个指令无需写回寄存器                    |          将刚刚取出的valM写入寄存器: valM => R[rA]           |
| 更新PC |                          PC <= valP                          |                                                              |



##### pushq 和 popq 指令

多了操作%rsp寄存器的操作

|  阶段  |                            pushq                             |                             popq                             |
| :----: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 取指令 | 两个取指令都是一样的: 取指令: icode:ifun <= M1[PC] 取寄存器: rA:rB <= M1[PC+1], 注意mrmovq解释寄存器的顺序相反 指令是2字节长度, 计算出新的PC地址: valP = PC + 2 |                                                              |
|  译码  | pushq的译码要注意, 在指令里取出来的rB是F, 但是这里实际操作需要从rA中取到valA, 因为这是要压栈的数据. 此外还自动从当前的%rsp中取出当前的栈地址, 当做valB M8[rA] => valA M8[%rsp] => valB | popq这里更特别, 由于是从栈里取数, 现在寄存器中的值是什么无需关心, 这里取两次%rsp的值分别放入valA和valB: R[%rsp] => valA R[%rsp] => valB |
|  执行  | 想一想之前的要求, 在写入内存之后, 更新栈指针. 要先计算出来写入内存之后新的栈顶指针. 由于栈顶指向的是第一个元素, 所以要算出来新的栈顶地址: valB – 8 => valE | 对比一下pushq, 当前的%rsp指向的是当前的栈顶, 要先计算出来弹栈之后的下一个栈顶地址: valB + 8 => valE |
|  访存  | 访存对于两个指令来说很关键, 压栈就是将valA压入新的栈顶对应的地址: valA => M8[valE] | 弹栈这里要注意, 是从原来的栈顶, 也就是valA中读出数据, 不是valE M8[valA] => valM |
|  写回  | 这里要注意, 写回的时候写哪个? 显然是更新过的栈指针valE valE => R[%rsp] | 这里要注意, 写回栈指针用的也是更新过的栈指针valE valE => R[%rsp] 此外由于是弹栈, 还需要将读取的valM写入到rA寄存器中来: valM => R[rA] 注意这是有顺序的, valM后发生 |
| 更新PC |           这2个指令都是2字节, 所以 newPC <= PC + 2           |                                                              |

##### call 和 ret

 由于跳转的本质就是更新程序计数器, 所以在更新PC的阶段, 会根据CC码来判断要将跳转的地址写入PC, 还是仅仅更新PC到下一条指令的地址.

| 阶段   | jxx Dest                                                     | call Dest                                                    | ret                                                          |
| ------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 取指令 | M1[PC] => icode:ifun valC => M8[PC+1] 取跳转地址 valP = PC +9, 9字节长的指令 | 与jxx 指令完全相同: M1[PC] => icode:ifun valC => M8[PC+1] valP = PC +9, 9字节长的指令 | ret指令是1字节指令, 无需取常数: M1[PC] => icode:ifun valP = PC +1 |
| 译码   | jxx无需译码, 因为不需要操作寄存器和内存, 要跳转的地址valC和下一条指令地址valP均已知 | call包含了压栈操作, 按照压栈的流程, valA由于没有, 就用不到, 但是要把当前栈地址取出来: R[%rsp] => valB | ret包含了弹栈操作, 所以是valA和valB都要设置成%rsp R[%rsp] => valA R[%rsp] => valB |
| 执行   | jxx的执行阶段会根据跳转功能, 检测对应的条件码, 然后更新Cnd码 Cond(CC, ifun) => Cnd 信号 | 压栈, 所以栈指针-8 valE = valB – 8                           | 弹栈, 栈指针+8 valE = valB + 8                               |
| 访存   | 完全不需要访存                                               | 压栈, 将下一条地址压入栈中, 下一条地址是已经计算出的valP valP => M8[%rsp] | 弹栈, 用原始的栈指针去读valM, valM就是将跳转的地址 valM = M8[valA] |
| 写回   | 也无需写回                                                   | 更新%rsp 为 -8 之后的数字 valE => R[%rsp]                    | 将栈地址更新到 +8 的地址, 由于不涉及其他寄存器, 无需将值写入其他寄存器, 只更新栈指针寄存器: valE => R[%rsp] |
| 写回   | 这里很关键, 根据Cnd信号, 决定是把下一条地址写入PC(即不跳转), 还是把常数地址valC写入PC(即执行跳转): Cnd? valC: valP => PC | 由于压完了当前下一条地址, 下边就要跳转了, 所以是把常数valC 写入 PC: valC => PC | 从内存中读取了要跳转的地址 valM, 很显然要把valM 写入 PC: valM => PC |

### 4.3.2 SEQ硬件结构

主要是看图理解.

### 4.3.3 SEQ的时序

SEQ的实现包括组合逻辑和两种存储器设备:时钟寄存器(程序计算器和条件码寄存器),随机访问存储器(寄存器文件、指令内存和数据内存)

组合逻辑不需要任何时序或控制--只要输入变化了,值就通过逻辑门网络传播.

由于指令内存只用来读指令,因此我们可以将这个单元看成是组合逻辑.

现在还剩四个硬件的单元需要对它们的时序进行明确的控制--程序计数器.条件码寄存器,数据内存和寄存器文件.

要控制处理器中活动的时序,只需要寄存器和内存的时钟控制.

原则: 绝不回读

### 4.4 流水线的通用原理

流水线化的一个重要特性就是提高了系统的吞吐量,也就是单位时间内执行的指令总数,不过它也会轻微地增加延迟,也就是执行一个指令所需要的时间.

流水线的局限性:

* 不一致的划分
* 流水线过深,收益反而下降

### 4.5 Y86-64的流水线实现

* SEQ+: 重新安排计算阶段.

* 插入流水线寄存器

* 对信号进行重新排列和标号

* 预测下一个PC

* 流水线冒险

  
## Programming Assignment III(PA4)

### 1 Introduction

> ``semantics``:语义分析

*实现静态静态语义分析*.

> `abstract syntax trees(AST)`:抽象语法树

你的语义分析应该拒绝错误的程序.

> `code generation`:代码生成器

对于正确的程序,它必须收集某些信息以供代码生成器使用.

语义分析器的输出是代码生成器使用的带注释的AST

这个assignment有比以前更大的设计空间

<u>There is no one “right” way to do the assignment, but there are wrong ways.</u>



* 您需要引用Cool参考手册中定义的类型规则、标识符作用域规则和其他限制。
* 您也需要讲method和和data member添加到此阶段的AST类定义中.
* 树package提供的函数都记录在`Tour of Cool Support Code.`中

这份讲义里面有很多信息,您需要了解其中的大部分内容才能编写一个有效的语义分析器.

请仔细阅读`handout`

高水平,你的语义分析器必须要完成下列的任务:

1. 查看所有的class并构造inheritance graph(继承图)
2. 检查graph的格式是不是正确的
3. 对于每一个类
   1. 遍历AST,在符号表中收集所有课件的declarations(声明)
   2. 检查每个expression的type是不是正确的
   3. 用类型注释AST

这个任务列表并不是详尽的,应该由你忠实地实现手册中的规则.

### 2 File and Directories

* `cool-tree.h`:这个文件是放置AST的用户定义拓展的地方.您可能需要添加其他声明,但不要修改现有的声明.

* `semant.cc`:这是你实现语义分析阶段的主要文件.它包括一些为了方便而预先定义的符号,以及一个用于表示`inheritance graph`的ClassTable方法的开始.你可以选择使用它或者忽略它.

  语义分析器是通过`program-class`类的`semant()`方法来调用.`program-class`的类声明在位于`cool-tree.h`中.任何你在`cool-tree.h`中声明的方法都应该在这个文件中实现

* `semant.h`:此文件是`semant.cc`的头文件.在这里添加所需的任何附加声明(不是在CoolTree.h中)

### 3 Tree Traversal

​		作为Assignment2的结果,你的`parser`构建了一个AST.`dump_with_types`方法,定义在大多数AST的节点,说明了如何遍历AST并从中收集信息.这种算法风格,`复杂树结构的递归遍历`,非常重要,因为它是在AST上构造许多计算的一种非常自然的方法.

 		此作业的编程任务是:(1)遍历树;(2)管理从树中收集到的各种信息;(3)使用这些信息来增强Cool的语义.AST的一个遍历称为"PASS".您可能需要至少两次通过AST来检查所有内容.

​		您很可能需要将自定义信息附加到AST节点上.要做到这一点,您可以直接编辑`cool-tree.h`.您希望添加的方法实现应该进入`semant.cc`.

### 4 Inheritance

​		继承关系指定类依赖的有向图.大多数具有继承的语言的一个典型要求是继承图是无循环的.执行这一要求取决于您的语义检查.一个相当简单的方法是构造一个类型图的表示,然后检查循环.

​		此外,Cool对从基本类继承有限制(请参阅手册).如果A类继承了B类,但是未定义B类,则这也是一个错误.

​		这个项目框架包括所有基本类的适当定义.您需要将这些类合并到继承层次结构中.

​		我们建议您将语义分析阶段划分为两个较小的组件.首先,检查继承图是否定义良好,这意味着对继承的所有限制都得到满足.如果继承图没有很好的定义,那么中止编译是可以接受的(当然!在打印适当的错误消息之后);第二,检查其他语义条件.如果知道继承图并且它是合法的,那么实现第二个组件就容易多了.

### 5 Naming and Scoping

​		对语义检查器的一个主要部分是名称的管理.具体问题是确认对标识符的每次使用都是有效的声明,特别是当名称可以重用时.例如,如果变量`i`是在两个`let`表达式中声明的,一个嵌套在另一个表达式中,那么无论在哪里引用`i`,语言的语义都会指定哪个声明是有效的.(作用域?)语义检查器的工作是追踪名称所指的声明.

​		正如在类中所讨论的,`symbol table`是管理名称和作用域的一种方便的数据结构.您可以为您的项目使用我们的符号表的实现.我们的实现提供了进入,退出,声明作用域的方法.当然,您也可以自由地实现自己的`symbol table`.

​		除了在每个类中隐式绑定标识符`self`之外,还有四种方法可以在Cool中引入`object name`:

  		1. 属性定义
        		2. 方法的形式参数
            		3. let expressions
                		4. branches of case statements	

​        除了`object`名称之外,还有方法名称和类名称.使用不能匹配声明的任何名称都是错误的.但是,在这种情况下,语义分析器在发现这样的错误不应该`abort`编译.请记住,在使用之前不需要声明任何类,方法或者属性.思考这回如何影响你的分析.

### 6 Type checking

​		类型检查是语义分析器的另一个主要功能.语义分析器必须检查是否在需要时声明有效类型.例如,必须声明方法的返回类型.使用这些信息,语义分析器还必须根据类型规则验证每个表达式是否具有有效类型.在cool参考手册和课程讲义中详细讨论了类型规则.

​		一个困难的问题是,如果表达式没有按照规则的有效类型,该怎么办.首先,应该用行号和错误描述打印错误信息.在语义分析阶段提供错误信息相对容易,因为通常很明显错误是什么.我们希望您提供错误信息.其次,语义分析器应该尝试恢复并继续.我们希望你的语义分析器能恢复,但是我们不期望它能避免`cascading errors`.一个简单的恢复机制是将类型对象分配给任何无法给出类型的表达式.

### 7  Code Generator Interface(接口)

​		为了使语义分析器与Coolc编译器的其他部分正常工作,必须注意遵守与代码生成器的接口.我们特意采用了一个非常简单的接口,以避免在语义分析中限制你的创造性灵感.但是,有一件你必须要做的事情.对于每一个表达式节点,它的类型字段必须设置为命名类型检查器推断的类型的符号.这个`Symbol`必须是`itable`的`add_string`方法的结果.必须要为特殊表达式`no-expr`分配`No_type`类型,它是项目框架中的预定义符号.

### 8 Expected Output

> `hierarchy`:层次

​		对于不正确的程序,语义分析的输出是`error`信息.除了格式错误的类层次结果之外,您需要从所有错误中恢复(?).您还需要产生完整和信息丰富的错误.假设继承层次结构良好,则语义检查器应捕获并报告程序中的所有语义错误.你的错误信息不必与`Coolc`相同,也不需要与样例的二进制文件顺序相同.

​		我们向您提供了一个简单的错误报告方法:

> ostream& ClassTable::semant_error(Class_)

​		这个routine接受了一个`Class_`节点并返回了一个输出流,您可以使用它来编写错误消息.

​		由于解析器确保`Class_`节点存储定义类的文件(提醒类的定义不能跨文件拆分),因此可以从检测错误的AST节点获得错误信息的行号,并且从`enclosing class`中获得文件名.

​		对于正确的程序,输出是带类型注释的AST.您将根据语义阶段是否正确地使用类型对AST进行注释,以及语义阶段是否与Coolc代码生成器一起正确工作而对您进行打分.

### 9 Testing the Semantic Analyzer

​		您将需要一个工作的scanner和parser来测试您的语义分析器.		

----讲了一堆如何用你自己的pa2和pa3的事情----



### 10 Remarks

​		到目前为止,语义分析阶段是编译器中最大的组件.我们的解决方案是大约1300行详细记录的C++.如果在编写代码之前画一些时间来设计语义分析器,您将会更容易去编写.问问你自己:

1. 我需要检查什么要求?
2. 我需要做什么来检查一个要求?
3. 什么时候我需要检查需求所需要的信息?
4. 检查要求所需要的信息在哪里?

​		如果您可以为Cool的每个方面回答这些问题,那么实现solution应该是简单的.

### 11 Final Submission

讲怎么交作业的